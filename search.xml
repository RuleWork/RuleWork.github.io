<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一文讲透抽象类和接口</title>
      <link href="/2019/03/14/yi-wen-jiang-tou-chou-xiang-lei-he-jie-kou/"/>
      <url>/2019/03/14/yi-wen-jiang-tou-chou-xiang-lei-he-jie-kou/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是抽象类和接口"><a href="#什么是抽象类和接口" class="headerlink" title="什么是抽象类和接口"></a>什么是抽象类和接口</h4><p>抽象类：简而言之，用abstract关键词修饰的类就是抽象类，抽象类不能创建实例对象，即不能new对象。</p><p>接口：接口就是一种特殊的抽象类，接口中的所有方法都必须是抽象的且默认是public abstaract类型的。</p><h4 id="接口的思想是什么"><a href="#接口的思想是什么" class="headerlink" title="接口的思想是什么"></a>接口的思想是什么</h4><p>Java为什么在有了抽象类还需要提出接口？</p><p>因为抽象类依然没有摆脱类的概念，也就是说抽象类还必须由继承它的子类去实现抽象类中的抽象方法，本质上还是面向对象中的继承思想，而在现实世界中继承的关系虽然随处可见，但更多的思想是“对某种功能的实现“，比如客户提出我想要一个可以通信的工具，于是很多商家针对这种需求开发了对讲机，手机，固话等，可以明显的发现对讲机，手机，固话并不是对通信工具的继承，因为通信工具甚至没有一个具体的概念，也就是说它的抽象层次非常高，仅仅只是对”通信“这个功能的描述，而如果是传统的类就需要定义具体的属性，方法等。</p><p>所以，继面向对象后Java提出了面向接口编程，接口只定义模块之间的通信契约，而抽象类在代码实现方面发挥了具体作用，两者的应用范围是不一样的。</p><p>在jdk源码中随处可见的更多的是接口和抽象类，Java用接口的方式间接的实现了“多继承”，而声明接口创建实现类也是多态的一种体现。</p><pre class=" language-Java"><code class="language-Java">public interface Signal{}public SignalImpl implements Signal{}public class Test(){    Signal signal = new SignalImpl();}</code></pre><h4 id="深入两者的各种区别"><a href="#深入两者的各种区别" class="headerlink" title="深入两者的各种区别"></a>深入两者的各种区别</h4><p>1.抽象类可以有构造方法，接口中不能有。</p><p>2.抽象类中可以有普通成员变量，接口中不能有。</p><p>3.抽象类可以包含非抽象的普通方法，接口在jdk中也可以，但必须用default修饰方法。</p><pre class=" language-Java"><code class="language-Java">public interface Test {        default int sum(int i,int j) {        return i * j;    }}</code></pre><p>但不推荐这么做，应该尽可能的写成</p><pre><code>public interface Test {        int sum(int i,int j);            }}</code></pre><p>以供实现类去实现这个方法。</p><p>4.抽象类中的抽象方法的访问类型可以是public,protected,默认，但静态抽象方法不能是默认的，而接口默认即为public abstract。</p><p>5.抽象类中可以包含静态方法，但接口中不能包含静态方法。</p><p>6.抽象类和接口中都可以包含静态成员变量，抽象类中静态成员变量访问类型可以任意，但接口中定义的成员变量只能是public static final类型，并且默认如此。</p><p>7.一个类可以实现多个接口，但只能继承一个抽象类。</p><h4 id="一个抽象类的经典应用"><a href="#一个抽象类的经典应用" class="headerlink" title="一个抽象类的经典应用"></a>一个抽象类的经典应用</h4><p>模板方法设计模式是抽象类的一个典型应用，假设某个项目中所有的Servlet类都要 用相同的方式进行权限判断，记录访问日志，异常处理，那么就可以定义一个抽象的基类，在抽象基类的service方法中完成所有的逻辑。</p><p>例如：</p><blockquote><p>localhost:8080/store/productServlet?method=addProduct</p></blockquote><p>我们可以在访问productServlet传入一个方法addProduct，定义一个BaseServlet继承自HttpServlet抽象类。</p><p>采用底层字节码技术就可以实现通用的逻辑设计</p><pre class=" language-Java"><code class="language-Java">public class abstract BaseServlet extends HttpServlet {    @Override    public void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        // localhost:8080/store/ProductServlet?method=findProductByPid&pid=1        String method = req.getParameter("method");        if (null == method || "".equals(method) || method.trim().equals("")) {            method = "execute";        }        Class clazz = this.getClass();        try {            Method md = clazz.getMethod(method, HttpServletRequest.class, HttpServletResponse.class);            if(null!=md){                String jspPath = (String)md.invoke(this, req, resp);                if (null != jspPath) {                    req.getRequestDispatcher(jspPath).forward(req, resp);                }            }        } catch (Exception e) {            e.printStackTrace();        }    }    // 默认方法    public String execute(HttpServletRequest req, HttpServletResponse resp) throws Exception {        return null;    }</code></pre><pre class=" language-Java"><code class="language-Java">public class ProductServlet extends BaseServlet {    public String findProductByPid(HttpServletRequest req, HttpServletResponse resp) throws Exception {        //获取商品pid        String pid = req.getParameter("pid");        //根据商品pid查询商品信息        IProductService prodectService = new ProductServiceImpl();        Product product = prodectService.findByProductByPid(pid);        //将获取到的商品放入request        req.setAttribute("product", product);        //转发/jsp/product_info.jsp        return "/jsp/product_info.jsp";    }}</code></pre><p>如此一来就不用直接继承自HttpServletRequest写大量的doGet,doPost方法,看起来就立马清爽了许多。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文讲透hashCode和equals方法</title>
      <link href="/2019/03/13/yi-wen-jiang-tou-hashcode-he-equals-fang-fa/"/>
      <url>/2019/03/13/yi-wen-jiang-tou-hashcode-he-equals-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>本文主要回答一下几个问题，意在消除所有关于HashCode和equals方法的模糊地带，彻底掌握这个知识点，虽然HashCode和equals是Java中的基础概念但是包含的内容却一点也不少，所谓基础不牢，地动山摇，所以大家还是重视。</p><p><strong>0.到底什么是hashCode，什么又是equals，跟==有什么区别？</strong></p><p><strong>1.Java为什么要设计hashCode和equals?</strong></p><p><strong>2.为什么比较对象的时候一定要重写hashCode和equals?</strong></p><p><strong>3.hashCode是怎么算出来的？</strong></p><p><strong>4.String的equals源码剖析。</strong></p><p>我们先讲一下为什么要设计hashCode，其实hashCode的诞生就是为Java中的集合服务的，例如Map和Set。</p><p>我们都知道HashMap是一种基于键值对形式的高效存储方式(底层采用数组加链表)，那么HashMap是如何保证键的唯一性的，其实就用到了hashCode，而另一个我们熟知的HashSet，它其中的元素是不重复的，那如何判断放入的元素是不重复的呢？其实也是用了hashCode。(下面会解释)。</p><p>先来看看hashCode到底是什么？简单来说，hashCode就是<strong>根据某种hash算法得到的int类型的值</strong>，哈希即散列，是一种高效的数据结构(不熟悉这种数据结构的建议先百度补课)，而hash算法的目的就是尽量减少哈希冲突，尽量使每个对象都能有自己的hash值，而这个值就是hashCode，就好像一个人的身份证一样，唯一标识着一个人的身份，因此同一个对象调用多次hashCode一定是一样的。</p><p>那么这种hash算法究竟是怎么算出来的，为什么能够尽可能的避免了哈希冲突呢？</p><p>我们来看源码：</p><p><img src="C:\Users\acer\Desktop\HashCode.png" alt="HashCode"></p><p>首先可以看到Object类中的hashCode是native方法，jdk底层有些是用C/C++写的，因此我们追溯到C++源码上(如何查看native方法的源码自行百度，这里不是重点)。</p><p><img src="C:\Users\acer\Desktop\C++源码.png" alt="C++源码"></p><p>再追踪核心代码ObjectSynchronizer的源码</p><p><img src="C:\Users\acer\Desktop\ObjectSynchronizer.png" alt="ObjectSynchronizer"></p><p>可以看到代码多次出现了指针，可以判断hashCode其实就是根据对象的地址进行相关的计算得到的，而这种计算必须具体到某一个对象上，重写了hashCode方法之后才能知道到底进行了怎样的运算，下面我们来举个简单的例子：</p><p><img src="C:\Users\acer\Desktop\360截图17290508589593.png" alt="360截图17290508589593"></p><p>在eclipse中我们定义一个Peson类，有一个age属性，然后利用IDE工具直接自动生成hashCode方法，重写Object类中的hashCode方法。这里我们可以看到首先生成一个prime=31，定义一个result，然后下面利用prime乘result加上age计算完成后进行返回。</p><p>这里就必须要面对一个问题，为什么要定义一个final的prime值，而且是31，这就涉及到计算机组成原理方面的知识。</p><p>在《Effective Java》第 42 页就有对 hashCode 为什么采用 31 做了说明：</p><blockquote><p>之所以使用 31， 是因为他是一个奇素数。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算（低位补0）。使用素数的好处并不很明显，但是习惯上使用素数来计算散列结果。 31 有个很好的性能，即用移位和减法来代替乘法，可以得到更好的性能： 31 * i == (i &lt;&lt; 5） - i， 现代的 VM 可以自动完成这种优化。这个公式可以很简单的推导出来。</p></blockquote><p>这里大家不必深究下去，具体为何选择31其实是数学家和统计学家要考虑的问题，我们只需要知道这个31主要是为了计算机底层的效率就行。</p><p>那为何比较对象的时候要重写hashCode呢？</p><p>我们先来回顾一下比较两个对象和基本数据类型的知识。</p><p><img src="C:\Users\acer\Desktop\360截图17290508417876.png" alt="360截图17290508417876"></p><p>如图，==是用来判断地址的，如果是基本数据类型a==b返回的是true，这是因为基本数据类型是在栈中存储的，因此值相等，则必定相等。而p1==p2返回的则是false，是因为new出来的对象地址是在堆内存中，每一次new出来的对象都占特定的堆内存，因此地址必定不相同。</p><p>那么如果我这里没有重写equals方法，来用equals比较</p><pre class=" language-Java"><code class="language-Java">System.out.println(p1.equals(p2));</code></pre><p>会发现依然会返回false，这是因为没有重写equals，对象会默认调用Object类的equals方法，源码如下：</p><pre><code>public boolean equals(Object obj) {        return (this == obj);}</code></pre><p>可以发现Object默认还是用==判断，所以如果要比较对象的内容是否相等，切记一定要重写equals方法，只有这样才能返回true。</p><p>那hashCode和equals方法有什么联系？</p><p>简单来说如果两个对象equals相等，则它们的hashcode必须相等，而hashcode相等，equals则不一定相等。就好比，4个数，前两个数和后两个数相等，则前两数的和与后两数的和一定相等，但前两数的和与后两数的和相等，则前两数和后两数不一定相等，2+3=5,1+4=5。原因在于，前面我们说过hashCode是尽量保证唯一，尽量平均分布，但由于不可避免地会存在哈希值冲突的情况，此时两个对象即便hashCode相等，equals也不一定相等，而equals相等hashCode必定相等是跟String的源码息息相关的，我们最后解释。</p><p>而对象重写equals方法，它的内部是会将对象里的所有属性逐一进行地址和内容上的判断，如果全部都相等，则返回true，否则就会返回false，例如：<img src="C:\Users\acer\Desktop\360截图17860601474246.png" alt="360截图17860601474246"></p><p>这里我们还要注意一点，任何时候重写equals，都必须要同时重写hashCode，这两者是相伴而生的，不要去单一的重写其中某一个。这个在阿里巴巴的《开发手册》中名明确规定，原因是因为：</p><p>在Map 和Set 类集合中， 用到这两个方法时， 首先会判断hashCode 的值， 如果<br>hash 相等， 则再判断equals 的结果。 HashMap 的get(Object key) 判断代码如下：<img src="C:\Users\acer\Desktop\360截图17571121434953.png" alt="360截图17571121434953"></p><p>可以看到if条件表达式中的e.hash==hash 是先决条件， 只有相等才会执行阴影部分。如果不相等， 则阴影部分后边的equals 根本不会被执行。因此当两个对象hashCode相同时，还需要再调用equals 进行一次值的比较，但是， 若hashCode 都不同， 根据短路原则将直接判定对象不同， 跳过equals ， 这大大加快了冲突处理效率。</p><p>如果只重写equals 而不重写hashCode的话：</p><pre class=" language-Java"><code class="language-Java">Set<Person> hashSet = new HashSet<Person> ();Person a = new Person( l , "one") ;Person b = new Person( l , ”one” ) ;Person c = new Person( l , ”one” );hashSet.add(a);hashSet.add(b) ;hashSet.add(c) ;System.out.println(hashSet.size()) ;</code></pre><p>显然a,b,c三个对象的内容完全相同的，根据hashSet的去重特性，按理来说这里应该打印1，但是这里打印出来的结果却是3，原因是因为没有重写hashCode的话，每个new出来的对象的即使内容相等，hashCode却不相等(因为hashCode是根据对象的地址进行运算的，而堆内存的地址必定是不同的)，此时hashSet的去重特性无法发挥(即无法进一步判断他们的值是否相同，因为hashCode不同，根据短路原则一票否决了)。所以如果不重写hashCode()，即使equals()相等也毫无意义，而只要像这样重写hashCode：</p><pre><code>@Overridepublic int hashCode() {    return age + name.hashCode() ;}</code></pre><p>此时hashCode方法已经与对象的地址无关了，而只跟对象属性的内容有关。也就是说a,b,c此时的hashCode是相同的，<strong>age + name.hashCode() ;</strong>因为age是基本数据类型，而name是String类型(String类内部已经重写了hashCode()，所以此时直接调用即可)，只要我们查看String源码后，如果String的hashCode()方法是字符串相同返回hashCode也相同，那么此时hashCode就肯定相同了，这样一来也就可以发挥hashSet的去重功能了。</p><p>所以最后我们来看一下String 的hashCode源码，分析为何equals相等则hashCode肯定相等。<img src="C:\Users\acer\Desktop\360截图19000807407664.png" alt="360截图19000807407664"></p><p>可以看到String的hashcode方法的实现原理是将字符串变成char[]数组，从而对字符串中的字符进行逐一的比较，所以字符串内容相同，它的hashCode肯定是相同的。而一个对象的属性要么就是基本数据类型，要么就是引用类型，而给引用类型用构造方法或者set方法赋值时本质上就是赋字符串！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法，数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断奇偶</title>
      <link href="/2019/03/12/pan-duan-qi-ou/"/>
      <url>/2019/03/12/pan-duan-qi-ou/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在知乎上看到一位大佬分享了一道面试题，题目很简单，但对基础考察的淋漓尽致，很有启发意义，分享给大家。</p></blockquote><p><strong>题目：判断一个数的是奇数。</strong></p><p>相当一部分人会这样写：</p><pre class=" language-Java"><code class="language-Java">public boolean Odd(int i){    if(i%2 == 1){        return true;    }else{        return false;    }}</code></pre><p>有没有更简单的写法呢？</p><p>我们可以优化一下，<strong>将判断后的结果直接做为返回值</strong></p><pre class=" language-Java"><code class="language-Java">public boolean isOdd(int i){    return i%2 == 1;}</code></pre><p>但是那这会导致一个什么问题呢？</p><p>很简单，如果我们传入一个负奇数，显然就会判断错误，因为奇数也分正负。</p><p>例如：传入一个-1，是奇数，但会返回false.</p><p>如何解决呢？也许可以这样解决。</p><pre class=" language-Java"><code class="language-Java">public boolean isOdd(int i){    return i%2 == 1 || i%2 == -1;}</code></pre><p>我们还可以优化一下：</p><pre class=" language-Java"><code class="language-Java">public boolean isOdd(int i){    return i%2 != 0;}</code></pre><p>到了这里，已经满足题目的要求了。</p><p>接下来我们再来尝试一下能否继续优化？</p><p>我们会发现奇数和偶数转换成二进制的区别是奇数最后一位是1，偶数是0。</p><p>继而会想到用位运算来代替取模运算来进行优化，<strong>因为在计算机的底层移位运算的效率是远远大于取模运算的。</strong></p><p>有的人可能瞬间想到了这样写：</p><pre class=" language-Java"><code class="language-Java">public boolean isOdd(int i){    return 1 >> 1 << 1 !=i;}</code></pre><p>但这并不是重点，应该想到的是按位与运算：</p><pre class=" language-Java"><code class="language-Java">public boolean isOdd(int i){    return i & 1 == 1;}</code></pre><p>然而这样写编译都会出错，因为==运算的优先级大于&amp;运算。所以：</p><pre class=" language-Java"><code class="language-Java">public boolean isOdd(int i){    return (i & 1) == 1;}</code></pre><p>例如：传入5,5的二进制是101,101&amp;001,结果是001。这里显然进行的也是位运算，因此效率应该比模运算高。</p><p>这总大圆满了吧，绝杀来了。</p><p><strong>然而经过测试发现实际的运行效率并没有提高</strong>，这又是为什么呢？</p><p>答案是：编译器会将对2的指数取模操作，优化成位运算操作，也就是说底层已经自动实现了优化。</p><p>如果我们对class文件反汇编，就会发现return i%2 != 0;这一句用的是iand位移指令。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文讲透从输入URL到浏览器显示页面发生了什么</title>
      <link href="/2019/03/07/yi-wen-jiang-tou-cong-shu-ru-url-dao-liu-lan-qi-xian-shi-ye-mian-fa-sheng-liao-shi-me/"/>
      <url>/2019/03/07/yi-wen-jiang-tou-cong-shu-ru-url-dao-liu-lan-qi-xian-shi-ye-mian-fa-sheng-liao-shi-me/</url>
      
        <content type="html"><![CDATA[<p>这是一个老生常谈的话题，今天我们再来详细想分析一波。</p><h6 id="1-浏览器对用户输入的网址-域名-做初步的格式化检查，域名是一个逻辑概念"><a href="#1-浏览器对用户输入的网址-域名-做初步的格式化检查，域名是一个逻辑概念" class="headerlink" title="1.浏览器对用户输入的网址(域名)做初步的格式化检查，域名是一个逻辑概念"></a>1.浏览器对用户输入的网址(域名)做初步的格式化检查，域名是一个逻辑概念</h6><h6 id="2-浏览器对用户输入的网址默认进行https补全。"><a href="#2-浏览器对用户输入的网址默认进行https补全。" class="headerlink" title="2.浏览器对用户输入的网址默认进行https补全。"></a>2.浏览器对用户输入的网址默认进行https补全。</h6><h6 id="3-浏览器将网址通过DNS协议解析成具体的IP地址"><a href="#3-浏览器将网址通过DNS协议解析成具体的IP地址" class="headerlink" title="3.浏览器将网址通过DNS协议解析成具体的IP地址"></a>3.浏览器将网址通过DNS协议解析成具体的IP地址</h6><p>PS：DNS(Domain Name System)，域名系统，是一个联机分布式数据库系统，并采用客户服务器方式，DNS大多数名字都在本地解析，少量解析需要在网络上，因此它的效率很高。IP地址的解析是由许多的域名服务器程序共同完成的。</p><p>1).查询浏览器的DNS缓存，可以使用 <a href="chrome://net-internals/#dns" target="_blank" rel="noopener">chrome://net-internals/#dns</a> 来查看，如果没有下一步</p><p>2).查询操作系统的DNS缓存,以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看，如果没有下一步</p><p>3).读取hosts文件（位于C:\Windows\System32\drivers\etc），查看有没有该域名对应的IP地址，如果没有下一步</p><p>4).联网向浏览器发起一个DNS的系统调用，向本地配置的ISP(互联网服务提供者)发起域名解析请求，通过的是UDP协议向DNS的53端口发起请求，这个请求是<strong>递归的请求</strong>，也就是的DNS服务器必须得提供给我们该域名的IP地址，ISP的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有ISP的DNS代我们的浏览器发起<strong>迭代DNS解析请求</strong>，它首先是会找根域的DNS的IP地址，这个DNS服务器都内置13台根域的DNS的IP地址(这里的13台根域名服务器其实并不真是13台，而是13个ip地址，采用任播技术，我们可以在全球设立这些ip的镜像站点，你访问到的ip并不是唯一的那台主机)，找到根域的DNS地址后，就会向其发起请求，例如<a href="http://www.cnblogs.com这个域名(www是三级域名，cnblog是二级，com是顶级)，根域发现这是一个顶级域com域的一个域名，于是就告诉ISP的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它，于是ISP的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求，请问www.cnblogs.com这个域名的IP地址是多少?com域这台服务器告诉运营商的DNS我不知道www.cnblogs.com这个域名的IP地址，但是我知道www.cnblogs.com这个域的DNS地址，你去找它去，于是ISP的DNS又向www.cnblogs.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.cnblogs.com这个域名的IP地址是多少？），这个时候cnblogs.com域的DNS服务器一查，果真在我这里，于是就把找到的结果发送给ISP的DNS服务器，这个时候运营商的DNS服务器就拿到了www.cnblogs.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.cnblogs.com对应的IP地址，该进行一步的动作了。" target="_blank" rel="noopener">www.cnblogs.com这个域名(www是三级域名，cnblog是二级，com是顶级)，根域发现这是一个顶级域com域的一个域名，于是就告诉ISP的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它，于是ISP的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求，请问www.cnblogs.com这个域名的IP地址是多少?com域这台服务器告诉运营商的DNS我不知道www.cnblogs.com这个域名的IP地址，但是我知道www.cnblogs.com这个域的DNS地址，你去找它去，于是ISP的DNS又向www.cnblogs.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.cnblogs.com这个域名的IP地址是多少？），这个时候cnblogs.com域的DNS服务器一查，果真在我这里，于是就把找到的结果发送给ISP的DNS服务器，这个时候运营商的DNS服务器就拿到了www.cnblogs.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.cnblogs.com对应的IP地址，该进行一步的动作了。</a></p><h6 id=""><a href="#" class="headerlink" title=""></a><img src="C:\Users\acer\Desktop\DNS解析.png" alt="DNS解析"></h6><h6 id="4-发起TCP的3次握手"><a href="#4-发起TCP的3次握手" class="headerlink" title="4.发起TCP的3次握手"></a>4.发起TCP的3次握手</h6><p>大概的过程就是：</p><ul><li>第一次握手： A给B打电话说，你可以听到我说话吗？</li><li>第二次握手： B收到了A的信息，然后对A说： 我可以听得到你说话啊，你能听得到我说话吗？  </li><li>第三次握手： A收到了B的信息，然后说可以的，我要给你发信息啦！</li></ul><p>　　<strong>在三次握手之后，A和B都能确定这么一件事： 我说的话，你能听到； 你说的话，我也能听到。</strong> <strong>这样，就可以开始正常通信了。</strong></p><h6 id="5-发送Http请求"><a href="#5-发送Http请求" class="headerlink" title="5.发送Http请求"></a>5.发送Http请求</h6><p>Http请求报文携带各种头部信息，大致分为三个部分：请求行、请求头、请求体。</p><p>请求行一般包括：服务器协议版本，状态码(2XX，表示处理成功；  4XX，表示客户端的错误；  5XX，表示服务器内部出错)</p><p>请求头一般包括：此次响应的时间、此次响应返回的文件长度、文件类型等等</p><p>请求体一般包括：服务器返回给客户端的文件、数据等（当请求时POST的时候才会有请求体）</p><h6 id="6-服务器处理后响应给客户端HTML文件"><a href="#6-服务器处理后响应给客户端HTML文件" class="headerlink" title="6.服务器处理后响应给客户端HTML文件"></a>6.服务器处理后响应给客户端HTML文件</h6><h6 id="7-浏览器解析html代码。"><a href="#7-浏览器解析html代码。" class="headerlink" title="7.浏览器解析html代码。"></a>7.浏览器解析html代码。</h6><p>浏览器拿到html文件后，就开始解析其中的html代码，遇到js/css/image等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这个时候就用上keep-alive特性了，建立一次HTTP连接，可以请求多个资源(HTTP的版本要为1.1)，下载资源的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，而浏览器又多线程请求请求资源，所以显示的顺序并不一定是代码里面的顺序。</p><p>如果浏览器在请求静态资源时（在未过期的情况下），向服务器端发起一个http请求（询问自从上一次修改时间到现在有没有对资源进行修改），如果服务器端返回304状态码（告诉浏览器服务器端没有修改），那么浏览器会直接读取本地的该资源的缓存文件。</p><h6 id="8-浏览器渲染页面"><a href="#8-浏览器渲染页面" class="headerlink" title="8.浏览器渲染页面"></a>8.浏览器渲染页面</h6><p>渲染的过程大致分为：</p><ol><li><strong>转换：</strong> 浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（如 UTF-8）将它们转换成各个字符。</li><li><strong>Tokenizing</strong>： 浏览器将字符串转换成 <a href="http://www.w3.org/TR/html5/" target="_blank" rel="noopener">W3C HTML5 标准</a>规定的各种tokens，例如，“<html>”、“<body>”，以及其他尖括号内的字符串。每个token都具有特殊含义和一组规则。</body></html></li><li><strong>词法分析：</strong> 发出的标记转换成定义其属性和规则的“对象”。</li><li><strong>DOM</strong> <strong>构建：</strong> 最后，由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：<em>HTML</em> 对象是 <em>body</em> 对象的父项，b<em>ody</em>是<em>paragraph</em>对象的父项，依此类推。</li></ol><p><strong>整个流程最终输出是页面的文档对象模型 (DOM)，浏览器对页面进行的所有进一步处理都会用到它。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法，数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解分而治之与快速排序</title>
      <link href="/2019/02/28/fen-er-zhi-zhi-yu-kuai-su-pai-xu/"/>
      <url>/2019/02/28/fen-er-zhi-zhi-yu-kuai-su-pai-xu/</url>
      
        <content type="html"><![CDATA[<h2 id="一-分而治之"><a href="#一-分而治之" class="headerlink" title="一.分而治之"></a>一.分而治之</h2><p>分而治之（divide and conquer,D&amp;C）是一种解决问题的重要的策略。它不仅是一种递归式的解决方法，更是一种分析问题的思维模式，尤其在程序设计中反映着一个人的算法内功，其重要性不言而喻。</p><p>下面我们先来假设这样一个场景：<br><strong>你要给自己的卧室铺瓷砖，卧室的地面空间是一个矩形，瓷砖是正方形，要求你将尽可能大的瓷砖均匀的铺在地面上，你会怎么做？</strong></p><p>这个问题有三个核心的关键点，<strong>首先要是正方形，然后要尽可能大，最后要均匀分布</strong>。</p><p><em>那么请你拿出一张纸，画出一个矩形，然后尝试着划分一下，如果你划分出来的方块其中有长方形，或者你划分的密密麻麻，或者你划分并不均匀（即里面的正方形有大小不一致的），出现这三种情况的任意一种，那很遗憾，这是不符合要求的！</em></p><p>这时我们就应该采取分而治之的策略！因为分而治之是递归的，因此我们需要解决两个步骤：</p><p><strong>1.找出基线条件，这种条件必须尽可能简单。</strong><br><strong>2.不断将问题分解（即缩小规模），直到符合基线条件。</strong></p><p>这里我们首先要介绍一种新的算法，即<strong>欧几里得算法</strong>（也叫辗转相除法），如果你还记得起数学归纳法你会很快理解它。</p><p><img src="https://img-blog.csdn.net/2018071022085798?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDk3ODIw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><em>两个整数的最大公约数是能够同时整除它们的最大的正整数。辗转相除法基于如下原理：两个整数的最大公约数等于其中较小的数和两数的差的最大公约数。例如，252和105的最大公约数是21（ 252 = 21 × 12 ； 105 = 21 × 5 ）；因为 252 − 105 = 21 × (12 − 5) = 147 ，所以147和105的最大公约数也是21。在这个过程中，较大的数缩小了，所以继续进行同样的计算可以不断缩小这两个数直至其中一个变成零。这时，所剩下的还没有变成零的数就是两数的最大公约数。由辗转相除法也可以推出，两数的最大公约数可以用两数的整数倍相加来表示，如 21 = 5 × 105 + (−2) × 252 。这个重要的结论叫做贝祖定理。</em></p><p>这种算法的思想其实类似于多米诺骨牌效应（数学归纳法也采用这种思想），即：<br>1.<strong>证明第一张骨牌会倒。</strong><br>2.<strong>证明只要任意一张骨牌倒了，那么与其相邻的下一张骨牌也会倒。</strong><br><strong>骨牌一个接一个倒下就如同一个值接下一个值</strong><br><strong>那么便可以下结论：所有的骨牌都会倒下。</strong><br>注意：虽然数学归纳法名字中有“归纳”，但是数学归纳法并非不严谨的归纳推理法，它属于完全严谨的演绎推理法。事实上，所有数学证明都是演绎法。</p><p>有了这种算法思想，我们再来解决铺瓷砖的这个问题就会变的异常轻松。<br>将结论中转换为这道题，就会变成<strong>适用于这小块地的最大方块，也是适用于整块地的最大方块。</strong></p><p>举个例子：<br>首先最容易处理的情况是，一边的长度是另一边的整数倍。<br>比如一长50，宽25的矩形你就会轻易的分出两个25X25的正方形。<br>而如果是一个长168，宽64的矩形，你应该这样分：先从这块矩形中划分出两个64X64的正方形（满足当前要求的最大正方形），那么就会产生一个64X40的新矩形，在该矩形中你采取同样的方式划分出一个40X40的正方形（满足当前要求的最大正方形），那么就又会产生一个24X40的矩形，再划分出一个24X24的正方形，产生一个24X16的矩形，再划分出一个16X16的正方形，产生一个16X8的矩形，最后划分出两个8X8的正方形，至此，你该片土地上，使用的最大瓷砖便为8X8的正方形！</p><p>这里我们重申一下D&amp;C的工作原理：<br><strong>1.找出简单的基线条件</strong><br><strong>2.确定如何缩小问题的规模，使其符合基线条件。</strong></p><h2 id="二-快速排序"><a href="#二-快速排序" class="headerlink" title="二.快速排序"></a>二.快速排序</h2><p>接下来，我们介绍一种常用的排序算法，比选择排序要快的多。例如：C语言中的qsort实现的就是快速排序，这种算法就使用了D&amp;C。</p><p>当我们对一个数组中的元素进行排序时，如果我们采用递归，那么基线条件就应该是当数组为空或者只包含一个元素时（即数组为空或为一个值时不需要排序）。</p><pre><code>def quicksort(array):    if len(array)&lt;2:        return array</code></pre><p>下面介绍快速排序的工作原理：<br>当一个数组中有多个数据元素时，例如：18,53,21,88,2,100,72利用D&amp;C，你需要将这个数组进行分解直到它满足基线条件为止，首先你需要从中选择一个元素，这个元素被称为<strong>基准值（pivot）</strong>，例如我们选择53（随意选取），接下来找出比基准值小的元素以及比基准值大的元素，并将小的放在基准值的左边，大的放在基准值的右边，此时即为18,21,2,53,88,72,100.这个过程称为<strong>分区(partitioning)</strong>，这里只是进行了分区，得到的左右两个数组仍然是无序的。如果我们能以同样的方式对子数组排序，最后合并结果就可以得到一个有序数组！</p><p>即我们对左子数组18,21,2,例如选取18作为基准值，小左大右，即变为2,18,21<br>即我们队右子数字88,72,100，例如选取88作为基准值，小左大右，即变为72,88,100</p><p>以此类推。。。</p><pre><code>quicksort([18，21,2]) + [53] + quicksort([88,72，100])&gt;[2,18,21,53,72,88,100]</code></pre><p>所以快排序的步骤如下：<br><strong>1）选择基准值</strong><br><strong>2）将数组拆分为两个子数组：小于基准值的元素和大于基准值的元素.</strong><br><strong>3） 对这两个子数组进行快速排序。</strong></p><h2 id="三-源代码（python）"><a href="#三-源代码（python）" class="headerlink" title="三.源代码（python）"></a>三.源代码（python）</h2><pre><code>def quicksort(array):    if len(array)&lt;2:        return array    else:        pivot = array[0]        less = [i for i in array[1:] if i&lt;=pivot]        greater = [i for i in array[1:] if i&gt;pivot]        return quicksort(less) + [pivot] +quicksort(greater)print quicksort([10,5,2,3])</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法，数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
