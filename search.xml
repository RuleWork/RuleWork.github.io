<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2019/03/07/yi-wen-jiang-tou-cong-shu-ru-url-dao-liu-lan-qi-xian-shi-ye-mian-fa-sheng-liao-shi-me/"/>
      <url>/2019/03/07/yi-wen-jiang-tou-cong-shu-ru-url-dao-liu-lan-qi-xian-shi-ye-mian-fa-sheng-liao-shi-me/</url>
      
        <content type="html"><![CDATA[<h1 id="一文讲透从输入URL到浏览器显示页面发生了什么"><a href="#一文讲透从输入URL到浏览器显示页面发生了什么" class="headerlink" title="一文讲透从输入URL到浏览器显示页面发生了什么"></a>一文讲透从输入URL到浏览器显示页面发生了什么</h1><p>这是一个老生常谈的话题，今天我们再来详细想分析一波。</p><h6 id="1-浏览器对用户输入的网址-域名-做初步的格式化检查，域名是一个逻辑概念"><a href="#1-浏览器对用户输入的网址-域名-做初步的格式化检查，域名是一个逻辑概念" class="headerlink" title="1.浏览器对用户输入的网址(域名)做初步的格式化检查，域名是一个逻辑概念"></a>1.浏览器对用户输入的网址(域名)做初步的格式化检查，域名是一个逻辑概念</h6><h6 id="2-浏览器对用户输入的网址默认进行https补全。"><a href="#2-浏览器对用户输入的网址默认进行https补全。" class="headerlink" title="2.浏览器对用户输入的网址默认进行https补全。"></a>2.浏览器对用户输入的网址默认进行https补全。</h6><h6 id="3-浏览器将网址通过DNS协议解析成具体的IP地址"><a href="#3-浏览器将网址通过DNS协议解析成具体的IP地址" class="headerlink" title="3.浏览器将网址通过DNS协议解析成具体的IP地址"></a>3.浏览器将网址通过DNS协议解析成具体的IP地址</h6><p>PS：DNS(Domain Name System)，域名系统，是一个联机分布式数据库系统，并采用客户服务器方式，DNS大多数名字都在本地解析，少量解析需要在网络上，因此它的效率很高。IP地址的解析是由许多的域名服务器程序共同完成的。</p><p>1).查询浏览器的DNS缓存，可以使用 <a href="chrome://net-internals/#dns" target="_blank" rel="noopener">chrome://net-internals/#dns</a> 来查看，如果没有下一步</p><p>2).查询操作系统的DNS缓存,以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看，如果没有下一步</p><p>3).读取hosts文件（位于C:\Windows\System32\drivers\etc），查看有没有该域名对应的IP地址，如果没有下一步</p><p>4).联网向浏览器发起一个DNS的系统调用，向本地配置的ISP(互联网服务提供者)发起域名解析请求，通过的是UDP协议向DNS的53端口发起请求，这个请求是<strong>递归的请求</strong>，也就是的DNS服务器必须得提供给我们该域名的IP地址，ISP的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有ISP的DNS代我们的浏览器发起<strong>迭代DNS解析请求</strong>，它首先是会找根域的DNS的IP地址，这个DNS服务器都内置13台根域的DNS的IP地址(这里的13台根域名服务器其实并不真是13台，而是13个ip地址，采用任播技术，我们可以在全球设立这些ip的镜像站点，你访问到的ip并不是唯一的那台主机)，找到根域的DNS地址后，就会向其发起请求，例如<a href="http://www.cnblogs.com这个域名(www是三级域名，cnblog是二级，com是顶级)，根域发现这是一个顶级域com域的一个域名，于是就告诉ISP的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它，于是ISP的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求，请问www.cnblogs.com这个域名的IP地址是多少?com域这台服务器告诉运营商的DNS我不知道www.cnblogs.com这个域名的IP地址，但是我知道www.cnblogs.com这个域的DNS地址，你去找它去，于是ISP的DNS又向www.cnblogs.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.cnblogs.com这个域名的IP地址是多少？），这个时候cnblogs.com域的DNS服务器一查，果真在我这里，于是就把找到的结果发送给ISP的DNS服务器，这个时候运营商的DNS服务器就拿到了www.cnblogs.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.cnblogs.com对应的IP地址，该进行一步的动作了。" target="_blank" rel="noopener">www.cnblogs.com这个域名(www是三级域名，cnblog是二级，com是顶级)，根域发现这是一个顶级域com域的一个域名，于是就告诉ISP的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它，于是ISP的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求，请问www.cnblogs.com这个域名的IP地址是多少?com域这台服务器告诉运营商的DNS我不知道www.cnblogs.com这个域名的IP地址，但是我知道www.cnblogs.com这个域的DNS地址，你去找它去，于是ISP的DNS又向www.cnblogs.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.cnblogs.com这个域名的IP地址是多少？），这个时候cnblogs.com域的DNS服务器一查，果真在我这里，于是就把找到的结果发送给ISP的DNS服务器，这个时候运营商的DNS服务器就拿到了www.cnblogs.com这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了www.cnblogs.com对应的IP地址，该进行一步的动作了。</a></p><h6 id=""><a href="#" class="headerlink" title=""></a><img src="C:\Users\acer\Desktop\DNS解析.png" alt="DNS解析"></h6><h6 id="4-发起TCP的3次握手"><a href="#4-发起TCP的3次握手" class="headerlink" title="4.发起TCP的3次握手"></a>4.发起TCP的3次握手</h6><p>大概的过程就是：</p><ul><li>第一次握手： A给B打电话说，你可以听到我说话吗？</li><li>第二次握手： B收到了A的信息，然后对A说： 我可以听得到你说话啊，你能听得到我说话吗？  </li><li>第三次握手： A收到了B的信息，然后说可以的，我要给你发信息啦！</li></ul><p>　　<strong>在三次握手之后，A和B都能确定这么一件事： 我说的话，你能听到； 你说的话，我也能听到。</strong> <strong>这样，就可以开始正常通信了。</strong></p><h6 id="5-发送Http请求"><a href="#5-发送Http请求" class="headerlink" title="5.发送Http请求"></a>5.发送Http请求</h6><p>Http请求报文携带各种头部信息，大致分为三个部分：请求行、请求头、请求体。</p><p>请求行一般包括：服务器协议版本，状态码(2XX，表示处理成功；  4XX，表示客户端的错误；  5XX，表示服务器内部出错)</p><p>请求头一般包括：此次响应的时间、此次响应返回的文件长度、文件类型等等</p><p>请求体一般包括：服务器返回给客户端的文件、数据等（当请求时POST的时候才会有请求体）</p><h6 id="6-服务器处理后响应给客户端HTML文件"><a href="#6-服务器处理后响应给客户端HTML文件" class="headerlink" title="6.服务器处理后响应给客户端HTML文件"></a>6.服务器处理后响应给客户端HTML文件</h6><h6 id="7-浏览器解析html代码。"><a href="#7-浏览器解析html代码。" class="headerlink" title="7.浏览器解析html代码。"></a>7.浏览器解析html代码。</h6><p>浏览器拿到html文件后，就开始解析其中的html代码，遇到js/css/image等静态资源时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这个时候就用上keep-alive特性了，建立一次HTTP连接，可以请求多个资源(HTTP的版本要为1.1)，下载资源的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，而浏览器又多线程请求请求资源，所以显示的顺序并不一定是代码里面的顺序。</p><p>如果浏览器在请求静态资源时（在未过期的情况下），向服务器端发起一个http请求（询问自从上一次修改时间到现在有没有对资源进行修改），如果服务器端返回304状态码（告诉浏览器服务器端没有修改），那么浏览器会直接读取本地的该资源的缓存文件。</p><h6 id="8-浏览器渲染页面"><a href="#8-浏览器渲染页面" class="headerlink" title="8.浏览器渲染页面"></a>8.浏览器渲染页面</h6><p>渲染的过程大致分为：</p><ol><li><strong>转换：</strong> 浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（如 UTF-8）将它们转换成各个字符。</li><li><strong>Tokenizing</strong>： 浏览器将字符串转换成 <a href="http://www.w3.org/TR/html5/" target="_blank" rel="noopener">W3C HTML5 标准</a>规定的各种tokens，例如，“<html>”、“<body>”，以及其他尖括号内的字符串。每个token都具有特殊含义和一组规则。</body></html></li><li><strong>词法分析：</strong> 发出的标记转换成定义其属性和规则的“对象”。</li><li><strong>DOM</strong> <strong>构建：</strong> 最后，由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：<em>HTML</em> 对象是 <em>body</em> 对象的父项，b<em>ody</em>是<em>paragraph</em>对象的父项，依此类推。</li></ol><p><strong>整个流程最终输出是页面的文档对象模型 (DOM)，浏览器对页面进行的所有进一步处理都会用到它。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/03/06/yi-wen-jiang-tou-chou-xiang-lei-he-jie-kou/"/>
      <url>/2019/03/06/yi-wen-jiang-tou-chou-xiang-lei-he-jie-kou/</url>
      
        <content type="html"><![CDATA[<h3 id="一文讲透抽象类和接口"><a href="#一文讲透抽象类和接口" class="headerlink" title="一文讲透抽象类和接口"></a>一文讲透抽象类和接口</h3><h4 id="什么是抽象类和接口"><a href="#什么是抽象类和接口" class="headerlink" title="什么是抽象类和接口"></a>什么是抽象类和接口</h4><p>抽象类：简而言之，用abstract关键词修饰的类就是抽象类，抽象类不能创建实例对象，即不能new对象。</p><p>接口：接口就是一种特殊的抽象类，接口中的所有方法都必须是抽象的且默认是public abstaract类型的。</p><h4 id="接口的思想是什么"><a href="#接口的思想是什么" class="headerlink" title="接口的思想是什么"></a>接口的思想是什么</h4><p>Java为什么在有了抽象类还需要提出接口？</p><p>因为抽象类依然没有摆脱类的概念，也就是说抽象类还必须由继承它的子类去实现抽象类中的抽象方法，本质上还是面向对象中的继承思想，而在现实世界中继承的关系虽然随处可见，但更多的思想是“对某种功能的实现“，比如客户提出我想要一个可以通信的工具，于是很多商家针对这种需求开发了对讲机，手机，固话等，可以明显的发现对讲机，手机，固话并不是对通信工具的继承，因为通信工具甚至没有一个具体的概念，也就是说它的抽象层次非常高，仅仅只是对”通信“这个功能的描述，而如果是传统的类就需要定义具体的属性，方法等。</p><p>所以，继面向对象后Java提出了面向接口编程，接口只定义模块之间的通信契约，而抽象类在代码实现方面发挥了具体作用，两者的应用范围是不一样的。</p><p>在jdk源码中随处可见的更多的是接口和抽象类，Java用接口的方式间接的实现了“多继承”，而声明接口创建实现类也是多态的一种体现。</p><pre class=" language-Java"><code class="language-Java">public interface Signal{}public SignalImpl implements Signal{}public class Test(){    Signal signal = new SignalImpl();}</code></pre><h4 id="深入两者的各种区别"><a href="#深入两者的各种区别" class="headerlink" title="深入两者的各种区别"></a>深入两者的各种区别</h4><p>1.抽象类可以有构造方法，接口中不能有。</p><p>2.抽象类中可以有普通成员变量，接口中不能有。</p><p>3.抽象类可以包含非抽象的普通方法，接口在jdk中也可以，但必须用default修饰方法。</p><pre class=" language-Java"><code class="language-Java">public interface Test {        default int sum(int i,int j) {        return i * j;    }}</code></pre><p>但不推荐这么做，应该尽可能的写成</p><pre><code>public interface Test {        int sum(int i,int j);            }}</code></pre><p>以供实现类去实现这个方法。</p><p>4.抽象类中的抽象方法的访问类型可以是public,protected,默认，但静态抽象方法不能是默认的，而接口默认即为public abstract。</p><p>5.抽象类中可以包含静态方法，但接口中不能包含静态方法。</p><p>6.抽象类和接口中都可以包含静态成员变量，抽象类中静态成员变量访问类型可以任意，但接口中定义的成员变量只能是public static final类型，并且默认如此。</p><p>7.一个类可以实现多个接口，但只能继承一个抽象类。</p><h4 id="一个抽象类的经典应用"><a href="#一个抽象类的经典应用" class="headerlink" title="一个抽象类的经典应用"></a>一个抽象类的经典应用</h4><p>模板方法设计模式是抽象类的一个典型应用，假设某个项目中所有的Servlet类都要 用相同的方式进行权限判断，记录访问日志，异常处理，那么就可以定义一个抽象的基类，在抽象基类的service方法中完成所有的逻辑。</p><p>例如：</p><blockquote><p>localhost:8080/store/productServlet?method=addProduct</p></blockquote><p>我们可以在访问productServlet传入一个方法addProduct，定义一个BaseServlet继承自HttpServlet抽象类。</p><p>采用底层字节码技术就可以实现通用的逻辑设计</p><pre class=" language-Java"><code class="language-Java">public class abstract BaseServlet extends HttpServlet {    @Override    public void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        // localhost:8080/store/ProductServlet?method=findProductByPid&pid=1        String method = req.getParameter("method");        if (null == method || "".equals(method) || method.trim().equals("")) {            method = "execute";        }        Class clazz = this.getClass();        try {            Method md = clazz.getMethod(method, HttpServletRequest.class, HttpServletResponse.class);            if(null!=md){                String jspPath = (String)md.invoke(this, req, resp);                if (null != jspPath) {                    req.getRequestDispatcher(jspPath).forward(req, resp);                }            }        } catch (Exception e) {            e.printStackTrace();        }    }    // 默认方法    public String execute(HttpServletRequest req, HttpServletResponse resp) throws Exception {        return null;    }</code></pre><pre class=" language-Java"><code class="language-Java">public class ProductServlet extends BaseServlet {    public String findProductByPid(HttpServletRequest req, HttpServletResponse resp) throws Exception {        //获取商品pid        String pid = req.getParameter("pid");        //根据商品pid查询商品信息        IProductService prodectService = new ProductServiceImpl();        Product product = prodectService.findByProductByPid(pid);        //将获取到的商品放入request        req.setAttribute("product", product);        //转发/jsp/product_info.jsp        return "/jsp/product_info.jsp";    }}</code></pre><p>如此一来就不用直接继承自HttpServletRequest写大量的doGet,doPost方法,看起来就立马清爽了许多。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>深入理解分而治之与快速排序</title>
      <link href="/2019/02/28/fen-er-zhi-zhi-yu-kuai-su-pai-xu/"/>
      <url>/2019/02/28/fen-er-zhi-zhi-yu-kuai-su-pai-xu/</url>
      
        <content type="html"><![CDATA[<h2 id="一-分而治之"><a href="#一-分而治之" class="headerlink" title="一.分而治之"></a>一.分而治之</h2><p>分而治之（divide and conquer,D&amp;C）是一种解决问题的重要的策略。它不仅是一种递归式的解决方法，更是一种分析问题的思维模式，尤其在程序设计中反映着一个人的算法内功，其重要性不言而喻。</p><p>下面我们先来假设这样一个场景：<br><strong>你要给自己的卧室铺瓷砖，卧室的地面空间是一个矩形，瓷砖是正方形，要求你将尽可能大的瓷砖均匀的铺在地面上，你会怎么做？</strong></p><p>这个问题有三个核心的关键点，<strong>首先要是正方形，然后要尽可能大，最后要均匀分布</strong>。</p><p><em>那么请你拿出一张纸，画出一个矩形，然后尝试着划分一下，如果你划分出来的方块其中有长方形，或者你划分的密密麻麻，或者你划分并不均匀（即里面的正方形有大小不一致的），出现这三种情况的任意一种，那很遗憾，这是不符合要求的！</em></p><p>这时我们就应该采取分而治之的策略！因为分而治之是递归的，因此我们需要解决两个步骤：</p><p><strong>1.找出基线条件，这种条件必须尽可能简单。</strong><br><strong>2.不断将问题分解（即缩小规模），直到符合基线条件。</strong></p><p>这里我们首先要介绍一种新的算法，即<strong>欧几里得算法</strong>（也叫辗转相除法），如果你还记得起数学归纳法你会很快理解它。</p><p><img src="https://img-blog.csdn.net/2018071022085798?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDk3ODIw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><em>两个整数的最大公约数是能够同时整除它们的最大的正整数。辗转相除法基于如下原理：两个整数的最大公约数等于其中较小的数和两数的差的最大公约数。例如，252和105的最大公约数是21（ 252 = 21 × 12 ； 105 = 21 × 5 ）；因为 252 − 105 = 21 × (12 − 5) = 147 ，所以147和105的最大公约数也是21。在这个过程中，较大的数缩小了，所以继续进行同样的计算可以不断缩小这两个数直至其中一个变成零。这时，所剩下的还没有变成零的数就是两数的最大公约数。由辗转相除法也可以推出，两数的最大公约数可以用两数的整数倍相加来表示，如 21 = 5 × 105 + (−2) × 252 。这个重要的结论叫做贝祖定理。</em></p><p>这种算法的思想其实类似于多米诺骨牌效应（数学归纳法也采用这种思想），即：<br>1.<strong>证明第一张骨牌会倒。</strong><br>2.<strong>证明只要任意一张骨牌倒了，那么与其相邻的下一张骨牌也会倒。</strong><br><strong>骨牌一个接一个倒下就如同一个值接下一个值</strong><br><strong>那么便可以下结论：所有的骨牌都会倒下。</strong><br>注意：虽然数学归纳法名字中有“归纳”，但是数学归纳法并非不严谨的归纳推理法，它属于完全严谨的演绎推理法。事实上，所有数学证明都是演绎法。</p><p>有了这种算法思想，我们再来解决铺瓷砖的这个问题就会变的异常轻松。<br>将结论中转换为这道题，就会变成<strong>适用于这小块地的最大方块，也是适用于整块地的最大方块。</strong></p><p>举个例子：<br>首先最容易处理的情况是，一边的长度是另一边的整数倍。<br>比如一长50，宽25的矩形你就会轻易的分出两个25X25的正方形。<br>而如果是一个长168，宽64的矩形，你应该这样分：先从这块矩形中划分出两个64X64的正方形（满足当前要求的最大正方形），那么就会产生一个64X40的新矩形，在该矩形中你采取同样的方式划分出一个40X40的正方形（满足当前要求的最大正方形），那么就又会产生一个24X40的矩形，再划分出一个24X24的正方形，产生一个24X16的矩形，再划分出一个16X16的正方形，产生一个16X8的矩形，最后划分出两个8X8的正方形，至此，你该片土地上，使用的最大瓷砖便为8X8的正方形！</p><p>这里我们重申一下D&amp;C的工作原理：<br><strong>1.找出简单的基线条件</strong><br><strong>2.确定如何缩小问题的规模，使其符合基线条件。</strong></p><h2 id="二-快速排序"><a href="#二-快速排序" class="headerlink" title="二.快速排序"></a>二.快速排序</h2><p>接下来，我们介绍一种常用的排序算法，比选择排序要快的多。例如：C语言中的qsort实现的就是快速排序，这种算法就使用了D&amp;C。</p><p>当我们对一个数组中的元素进行排序时，如果我们采用递归，那么基线条件就应该是当数组为空或者只包含一个元素时（即数组为空或为一个值时不需要排序）。</p><pre><code>def quicksort(array):    if len(array)&lt;2:        return array</code></pre><p>下面介绍快速排序的工作原理：<br>当一个数组中有多个数据元素时，例如：18,53,21,88,2,100,72利用D&amp;C，你需要将这个数组进行分解直到它满足基线条件为止，首先你需要从中选择一个元素，这个元素被称为<strong>基准值（pivot）</strong>，例如我们选择53（随意选取），接下来找出比基准值小的元素以及比基准值大的元素，并将小的放在基准值的左边，大的放在基准值的右边，此时即为18,21,2,53,88,72,100.这个过程称为<strong>分区(partitioning)</strong>，这里只是进行了分区，得到的左右两个数组仍然是无序的。如果我们能以同样的方式对子数组排序，最后合并结果就可以得到一个有序数组！</p><p>即我们对左子数组18,21,2,例如选取18作为基准值，小左大右，即变为2,18,21<br>即我们队右子数字88,72,100，例如选取88作为基准值，小左大右，即变为72,88,100</p><p>以此类推。。。</p><pre><code>quicksort([18，21,2]) + [53] + quicksort([88,72，100])&gt;[2,18,21,53,72,88,100]</code></pre><p>所以快排序的步骤如下：<br><strong>1）选择基准值</strong><br><strong>2）将数组拆分为两个子数组：小于基准值的元素和大于基准值的元素.</strong><br><strong>3） 对这两个子数组进行快速排序。</strong></p><h2 id="三-源代码（python）"><a href="#三-源代码（python）" class="headerlink" title="三.源代码（python）"></a>三.源代码（python）</h2><pre><code>def quicksort(array):    if len(array)&lt;2:        return array    else:        pivot = array[0]        less = [i for i in array[1:] if i&lt;=pivot]        greater = [i for i in array[1:] if i&gt;pivot]        return quicksort(less) + [pivot] +quicksort(greater)print quicksort([10,5,2,3])</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法，数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断奇偶</title>
      <link href="/2019/02/03/pan-duan-qi-ou/"/>
      <url>/2019/02/03/pan-duan-qi-ou/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在知乎上看到一位大佬分享了一道面试题，题目很简单，但对基础考察的淋漓尽致，很有启发意义，分享给大家。</p></blockquote><p><strong>题目：判断一个数的是奇数。</strong></p><p>相当一部分人会这样写：</p><pre class=" language-Java"><code class="language-Java">public boolean Odd(int i){    if(i%2 == 1){        return true;    }else{        return false;    }}</code></pre><p>有没有更简单的写法呢？</p><p>我们可以优化一下，<strong>将判断后的结果直接做为返回值</strong></p><pre class=" language-Java"><code class="language-Java">public boolean isOdd(int i){    return i%2 == 1;}</code></pre><p>但是那这会导致一个什么问题呢？</p><p>很简单，如果我们传入一个负奇数，显然就会判断错误，因为奇数也分正负。</p><p>例如：传入一个-1，是奇数，但会返回false.</p><p>如何解决呢？也许可以这样解决。</p><pre class=" language-Java"><code class="language-Java">public boolean isOdd(int i){    return i%2 == 1 || i%2 == -1;}</code></pre><p>我们还可以优化一下：</p><pre class=" language-Java"><code class="language-Java">public boolean isOdd(int i){    return i%2 != 0;}</code></pre><p>到了这里，已经满足题目的要求了。</p><p>接下来我们再来尝试一下能否继续优化？</p><p>我们会发现奇数和偶数转换成二进制的区别是奇数最后一位是1，偶数是0。</p><p>继而会想到用位运算来代替取模运算来进行优化，<strong>因为在计算机的底层移位运算的效率是远远大于取模运算的。</strong></p><p>有的人可能瞬间想到了这样写：</p><pre class=" language-Java"><code class="language-Java">public boolean isOdd(int i){    return 1 >> 1 << 1 !=i;}</code></pre><p>但这并不是重点，应该想到的是按位与运算：</p><pre class=" language-Java"><code class="language-Java">public boolean isOdd(int i){    return i & 1 == 1;}</code></pre><p>然而这样写编译都会出错，因为==运算的优先级大于&amp;运算。所以：</p><pre class=" language-Java"><code class="language-Java">public boolean isOdd(int i){    return (i & 1) == 1;}</code></pre><p>例如：传入5,5的二进制是101,101&amp;001,结果是001。这里显然进行的也是位运算，因此效率应该比模运算高。</p><p>这总大圆满了吧，绝杀来了。</p><p><strong>然而经过测试发现实际的运行效率并没有提高</strong>，这又是为什么呢？</p><p>答案是：编译器会将对2的指数取模操作，优化成位运算操作，也就是说底层已经自动实现了优化。</p><p>如果我们对class文件反汇编，就会发现return i%2 != 0;这一句用的是iand位移指令。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
